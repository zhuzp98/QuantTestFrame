// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) https://creativecommons.org/licenses/by-nc-sa/4.0/
// Â© rhapsodyz

//@version=5
strategy(title          = "LinReg 5m Quick Strategy", 
     shorttitle         = "LinReg 5m",
     overlay            = true, 
     pyramiding         = 0, 
     initial_capital    = 100000,
     default_qty_type   = strategy.percent_of_equity, 
     default_qty_value  = 100, 
     commission_type    = strategy.commission.percent, 
     commission_value   = 0.05, 
     slippage           = 2)

// #######################
// === General Numbers ===
// #######################

// === Equity Usage ===
equityUsage = input.float(0.9, title="Equity Usage Percentage", group = "General Settings")
_qty        = (strategy.equity * equityUsage) / close

// === Input A Linear Regression Channel ===
group1 = "Regression Settings"
group2 = "TP/SL Settings"

lengthInput         = input.int(60, minval = 1, maxval = 5000, title = "Regression Length", group = group1)
sourceInput         = input.source(hl2, title = "Regression Source", group = group1)
useUpperDevInput    = input.bool(true, title = "Upper Deviation", inline = "Upper Deviation", group = group1)
upperMultInput      = input.float(2.0, title = "", inline = "Upper Deviation", group = group1)
useLowerDevInput    = input.bool(true, title = "Lower Deviation", inline = "Lower Deviation", group = group1)
lowerMultInput      = input.float(2.0, title = "", inline = "Lower Deviation", group = group1)
showPearsonInput    = input.bool(false, title = "Pearson's R", inline = "Display Settings", group = group1)
extendLeftInput     = input.bool(false, title = "Extend Lines Left", inline = "Display Settings", group = group1)
extendRightInput    = input.bool(false, title = "Extend Lines Right", inline = "Display Settings", group = group1)
colorUpper          = input.color(color.new(color.blue, 85), title = "", inline = "Color Settings", group = group1)
colorLower          = input.color(color.new(color.red, 85), title = "", inline = "Color Settings", group = group1)
takeProfit          = input.float(0.618, minval = 0.382, maxval = 2.618, title = "TakeProfit", inline = "TP/SL Settings", group = group2)
stopLoss            = input.float(0.206, minval = 0.127, maxval = 0.872, title = "StopLoss", inline = "TP/SL Settings", group = group2)

// === Input B Multiple MA ===
group3      = "Multiple MA Settings"
baseType    = input.string("EMA", options = ["EMA", "SMA", "HMA"], title = "Base MA Type", inline = "Base MA", group = group3)
slowType    = input.string("HMA", options = ["EMA", "SMA", "HMA"], title = "Slow MA Type", inline = "Slow MA", group = group3)
fastType    = input.string("EMA", options = ["EMA", "SMA", "HMA"], title = "Fast MA Type", inline = "Fast MA", group = group3)
baseLength  = input.int(200, minval = 120, maxval = 720, title = "Base MA Length", inline = "Base MA", group = group3)
slowLength  = input.int(100, minval = 60, maxval = 200, title = "Slow MA Length", inline = "Slow MA", group = group3)
fastLength  = input.int(60, minval = 12, maxval = 60, title = "Fast MA Length", inline = "Fast MA", group = group3)

// === Input C RSI %B ===
group4 = "RSI %B Settings"
rsiLength       = input.int(6, minval=1, title="Length", inline = "RSI", group = group4)
rsiSource       = input.source(hlc3, "Source", inline = "RSI", group = group4)
rsiRawBreak     = input.int(25, minval = 1, title = "RSI Raw Breakout Value", group = group4)
rsiMALength     = input.int(14, title="Boll Length", group = group4)
rsiBollMult     = input.float(2.0, minval=0.001, maxval=50, title="Boll StdDev", group = group4)
rsiDivBreakLow  = input.float(0.9, minval=0.001, maxval=3, title="Breakout Value Low", group = group4)
rsiDivBreakHigh = input.float(1.4, minval=0.001, maxval=3, title="Breakout Value High", group = group4)

// ##################
// === Indicators ===
// ##################

// === Indicator A Linear Regression Channel ===

calcSlope(source, length) =>
    max_bars_back(source, 5000)
    if not barstate.islast or length <= 1
        [float(na), float(na), float(na)]
    else
        sumX = 0.0
        sumY = 0.0
        sumXSqr = 0.0
        sumXY = 0.0
        for i = 0 to length - 1 by 1
            val = source[i]
            per = i + 1.0
            sumX += per
            sumY += val
            sumXSqr += per * per
            sumXY += val * per
        slope = (length * sumXY - sumX * sumY) / (length * sumXSqr - sumX * sumX)
        average = sumY / length
        intercept = average - slope * sumX / length + slope
        [slope, average, intercept]
 
calcDev(source, length, slope, average, intercept) =>
    upDev = 0.0
    dnDev = 0.0
    stdDevAcc = 0.0
    dsxx = 0.0
    dsyy = 0.0
    dsxy = 0.0
    periods = length - 1
    daY = intercept + slope * periods / 2
    val = intercept
    for j = 0 to periods by 1
        price = high[j] - val
        if price > upDev
            upDev := price
        price := val - low[j]
        if price > dnDev
            dnDev := price
        price := source[j]
        dxt = price - average
        dyt = val - daY
        price -= val
        stdDevAcc += price * price
        dsxx += dxt * dxt
        dsyy += dyt * dyt
        dsxy += dxt * dyt
        val += slope
    stdDev = math.sqrt(stdDevAcc / (periods == 0 ? 1 : periods))
    pearsonR = dsxx == 0 or dsyy == 0 ? 0 : dsxy / math.sqrt(dsxx * dsyy)
    [stdDev, pearsonR, upDev, dnDev]
    
       
[s, a, i]                           = calcSlope(sourceInput, lengthInput)
[stdDev, pearsonR, upDev, dnDev]    = calcDev(sourceInput, lengthInput, s, a, i)

startPrice      = i + s * (lengthInput - 1)
endPrice        = i
upperStartPrice = startPrice + (useUpperDevInput ? upperMultInput * stdDev : upDev)
upperEndPrice   = endPrice + (useUpperDevInput ? upperMultInput * stdDev : upDev)
lowerStartPrice = startPrice + (useLowerDevInput ? -lowerMultInput * stdDev : -dnDev)
lowerEndPrice   = endPrice + (useLowerDevInput ? -lowerMultInput * stdDev : -dnDev)
widthChannel    = int(2 * upperMultInput * stdDev / syminfo.mintick)
dynFactor       = 
tpValue         = int(widthChannel*takeProfit)
slValue         = int(widthChannel*stopLoss)
float trend     = math.sign(startPrice - endPrice)

// === Indicator B Multiple MA ===

maSwitch(type, length) =>
    src = close
    if type == "EMA"
        ta.ema(src, length)
    if type == "SMA"
        ta.sma(src, length)
    if type == "HMA"
        ta.wma(2*ta.wma(src, length/2)-ta.wma(src, length), math.floor(math.sqrt(length)))

baseMA = maSwitch(baseType, baseLength)
slowMA = maSwitch(slowType, slowLength)
fastMA = maSwitch(fastType, fastLength)

// === Indicator C RSI %B ===

up      = ta.rma(math.max(ta.change(rsiSource), 0), rsiLength)
down    = ta.rma(-math.min(ta.change(rsiSource), 0), rsiLength)
rsi     = down == 0 ? 50 : up == 0 ? -50 : 50 - (100 / (1 + up / down))
rsiMA   = ta.ema(rsi, rsiMALength)
rsiDiv  = (rsi - rsiMA) / (ta.stdev(rsi, rsiMALength) * rsiBollMult)

// === Indicator D TD Sequantial ===

// #######################
// === Risk Management ===
// #######################

commissionCost = int(0.001 * close / syminfo.mintick)

// === Take-profit ===
tp1 = int(tpValue/3)
tp2 = int(2*tpValue/3)
tp3 = tpValue

_qty_pct1 = 0.3
_qty_pct2 = 0.3
_qty_pct3 = 0.3
_qty_pct4 = 0.1

// === Stop-loss ===
sl1 = - slValue
sl2 = commissionCost
sl3 = tp1
sl4 = tp2

// ##################
// === Conditions ===
// ##################

// === Condition A Linear Regression Channel ===
enterConditionLGC = tpValue/3 * 0.3 >= commissionCost
longLGC = close < endPrice - 0.25 * widthChannel
shortLGC = close > endPrice + 0.25 * widthChannel

// === Condition B ===

// === Condition C ===


// #######################
// === Order Execution ===
// #######################

// === Execute long entry ===
if enterLong
    stopLossPrice   := close * (1 - stopLoss/100)
    takeProfitPrice := close * (1 + takeProfit/100)
    strategy.entry("Long", strategy.long, qty = _qty)
    strategy.exit("exit", "Long", stop = stopLossPrice, limit = takeProfitPrice)

// === Execute long exit ===
if exitLong
    strategy.close("Long", qty_percent=100)

// === Execute short entry ===
if enterShort
    stopLossPrice   := close * (1 + stopLoss/100)
    takeProfitPrice := close * (1 - takeProfit/100)
    strategy.entry("Short", strategy.short, qty = _qty)
    strategy.exit("Exit", "Short", stop = stopLossPrice, limit = takeProfitPrice)

// === Execute short exit ===
if exitShort
    strategy.close("Short", qty_percent = 100)